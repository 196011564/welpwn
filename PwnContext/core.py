import os
import shutil
import re
from pwn import *
from pwnlib.context import _validator, _Tls_DictStack, _defaultdict
from os.path import realpath
from os.path import abspath
from proc import Proc

# two important functions
from utils.misc import libc_search, one_gadgets
'''This core script of `PwnContext` has been changed since 2018/11/6, as a result of a sky
size big bro telling me that the usage of the script is awful.
'''


class BetterDict(object):
    '''Just a dict that support a.b <==> a[b]

    Note:
        I didn't add normal dict methods into this class. Use BetterDict._dict directly.
    '''
    def __init__(self, _dict):
        self._dict = _dict
    def __repr__(self):
        return str(self._dict)
    def __str__(self):
        return str(self._dict)
    def __getitem__(self, key):
        return self._dict[key]
    def __iter__(self):
        for key in self._dict:
            yield key
    def __getattr__(self, key):
        if key in self._dict:
            return self._dict[key]


class PwnContext(object):
    '''PwnContext is designed for accelerating pwnning by automate many dull jobs.

    Examples:
        >>> ctx = PwnContext()
        >>> ctx.binary = '/bin/sh'
        >>> ctx.remote_libc = './libc.so.6'
        >>> ctx.remote = ('localhost', 1234)
    '''
    defaults = {
                'binary': None,
                'io': None,
                'proc': None,
                'remote': None,
                'remote_libc': None,
                'debug_remote_libc': False,
               }
    def __init__(self):
        self._tls = _Tls_DictStack(_defaultdict(PwnContext.defaults))
    
    @_validator
    def binary(self, binary):
        """ELF: Binary assigned to the PwnContext.

        Args:
            binary (str of ELF): Path to binary of ELF object.
        """
        if not binary: return None
        if not isinstance(binary, ELF):
            if not os.access(binary, os.R_OK): 
                log.failure("Invalid path {} to binary".format(binary))
                return None
            binary = ELF(binary)
        context.binary = binary
        return binary

    @_validator
    def remote_libc(self, libc):
        """ELF: Remote libc assigned to the PwnContext.
        """
        if not libc: return None
        if not isinstance(libc, ELF):
            if not os.access(libc, os.R_OK): 
                log.failure("Invalid path {} to libc".format(libc))
                return None
            libc = ELF(libc)
        return libc

    @_validator
    def io(self, io):
        """process or remote: IO assigned to the PwnContext.

        Note:
            Generated by PwnContext.start
        """
        if not isinstance(io, process) and not isinstance(io, remote):
            log.failure("Invalid io {}".format(io))
            return None
        return io

    @property
    def libc(self):
        """ELF: Dynamically find libc. If io is process, return its real libc.
        if is remote, return remote_libc.
        """
        if isinstance(self.io, remote):
            return self.remote_libc
        elif isinstance(self.io, process):
            return ELF(self.proc.libc_path)

    @property
    def proc(self):
        '''Proc: Implemented in PwnContext/proc.py
        '''
        if self.pid:
            return Proc(self.pid)
        else:
            return None

    @property
    def bases(self):
        '''dict: Dict of vmmap names and its start address.
        '''
        proc = self.proc
        if proc:
            return BetterDict(proc.bases)

    @property
    def canary(self):
        '''int: Canary value of the process.
        '''
        proc = self.proc
        if proc:
            return proc.canary

    @property
    def pid(self):
        '''int: pid of the process.
        '''
        if isinstance(self.io, process):
            return self.io.pid
        else:
            return None

    def start(self, method='process', **kwargs):
        '''Core method of PwnContext. Handles glibc loading, process/remote generating.

        Args:
            method (str): 'process' will launch a process instance, 'remote' will
            launch a remote instance and 'gdb' will launch process in debug mode.
            **kwargs: arguments to pass to process, remote, or gdb.debug.
        '''
        # checking if there is an open io, then close it.
        if self.io:
            self.io.close()

        if method == 'remote':
            if not self.remote:
                log.error("PwnContext.remote not assigned")
            self.io = remote(self.remote[0], self.remote[1])
            return self.io
        else:
            binary = self.binary
            if not binary:
                log.error("PwnContext.binary not assigned")

            # debug remote libc. be aware that this will use a temp binary
            if self.debug_remote_libc:
                env = {}
                path = self.remote_libc.path
                if 'env' in kwargs:
                    env = kwargs['env'] 
                if "LD_PRELOAD" in env and path not in env["LD_PRELOAD"]:
                    env["LD_PRELOAD"] = "{}:{}".format(env["LD_PRELOAD"], path)
                else:
                    env["LD_PRELOAD"] = path
                log.info("set env={} for debugging remote libc".format(env))
                kwargs['env'] = env
                # codes followed change the ld
                cur_dir = os.path.dirname(os.path.realpath(__file__))
                libc_version = get_libc_version(path)
                arch = ''
                if self.binary.arch == 'amd64':
                    arch = '64'
                elif self.binary.arch == 'i386':
                    arch = '32'
                else:
                    log.error('non supported arch')
                ld_path = "{}/libs/libc-{}/{}bit/ld.so.2".format(
                    cur_dir,
                    libc_version,
                    arch)
                shutil.copy(ld_path, '/tmp/ld.so.2')
                binary = change_ld(binary, '/tmp/ld.so.2')

            if method == 'gdb':
                self.io = binary.debug(**kwargs)
            elif method == 'process':
                self.io = binary.process(**kwargs)
            else:
                log.error('invalid method {}'.format(method))

            return self.io

    def __getattr__(self, attr):
        '''use ctx.io by default'''
        if hasattr(self.io, attr):
            def call(*args, **kwargs):
                return self.io.__getattribute__(attr)(*args, **kwargs)
            return call


ctx = PwnContext()


def change_ld(binary, ld):
    """
    Force to use assigned new ld.so by changing the binary
    """
    if not os.access(ld, os.R_OK): 
        log.failure("Invalid path {} to ld".format(ld))
        return None

        
    if not isinstance(binary, ELF):
        if not os.access(binary, os.R_OK): 
            log.failure("Invalid path {} to binary".format(binary))
            return None
        binary = ELF(binary)

    for segment in binary.segments:
        if segment.header['p_type'] == 'PT_INTERP':
            size = segment.header['p_memsz']
            addr = segment.header['p_paddr']
            data = segment.data()
            if size <= len(ld):
                log.failure("Failed to change PT_INTERP from {} to {}".format(data, ld))
                return None
            binary.write(addr, ld.ljust(size, '\0'))
            if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn')
            path = '/tmp/pwn/{}_debug'.format(os.path.basename(binary.path))
            if os.access(path, os.F_OK): 
                os.remove(path)
                info("Removing exist file {}".format(path))
            binary.save(path)    
            os.chmod(path, 0b111000000) #rwx------
    log.success("PT_INTERP has changed from {} to {}. Using temp file {}".format(data, ld, path)) 
    return ELF(path)

def get_libc_version(path):
    '''Get the libc version.

    Args:
        path (str): Path to the libc.
    Returns:
        str: Libc version. Like '2.29', '2.26' ...
    '''
    content = open(path).read()
    pattern = "libc[- ]([0-9]+\.[0-9]+)"
    result = re.findall(pattern, content)
    if result:
        return result[0]
    else:
        return ""
